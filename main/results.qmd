---
title: "A state-space model for projecting population abundance"
bibliography: references.bib
---

```{r setup, echo = FALSE, warning = FALSE, message = FALSE}

# Load required packages -------------------------------------------------------

library(pacman)
p_load(cmdstanr, tidyverse, here, tidybayes, brms, bayesplot, knitr, kableExtra,
       paletteer, ggridges)
#set_cmdstan_path("~/cmdstan")  # your `cmdstan` path may be different

# Initialize -------------------------------------------------------------------

# Data import
source(here("R", "read_abun_retro.R"))     #; Ndata; tail(Ndata)  # Check
source(here("R", "read_calf_enp_retro.R")) #; Cdata; tail(Cdata)  # Check
source(here("R", "read_strand_retro.R"))   #; Sdata; tail(Sdata)  # Check

# Abundance Estimates
Ndata_input = filter(Ndata, year >= 2002) #; tail(Ndata_input)  # Check
minYr <- Ndata_input %>% filter(year == min(year)) %>% pull(year)
maxYr <- Ndata_input %>% filter(year == max(year)) %>% pull(year)

# SWFSC ENP calf estimates
Cdata_input = filter(Cdata, year >= 2002) #; tail(Cdata_input)  # Check
Cdata_2020 <- Cdata_input %>%             # Impute mean of shoulder years for missing 2020 data
  slice(1) %>%
  mutate_all(~ NA) %>%
  mutate(
    year = 2020, method = "Mean of 2019 & 2021",
    mean_log = Cdata_input %>% filter(year >= 2019 & year <= 2021) %>% pull(mean_log) %>% mean(),
    sd_log = Cdata_input %>% filter(year >= 2019 & year <= 2021) %>% pull(sd_log) %>% mean()
  )

Cdata_input <- Cdata_input %>%
  add_row(Cdata_2020) %>%
  arrange(year) %>%

  # adding filler row for ENP calf data base on last year's
  # should be adjusted to some modeled estimate
  add_row(Cdata_input %>% filter(year == max(year)))

# Covariate data (point estimates only) on lambda; at present, 
# not the precise time series and should be viewed as a filler for model development
x_lambda = data.frame(
  N_pcfg_calves = c(9,4,5,3,0,3,2,1,4,6,12,14,17,12,7,4,4,2,4,5,2,11, # abundance data years
                   13,10), # projected years, real values exist.
  N_strandings = Sdata %>% filter(state == "All" & year >= 2002) %>% pull(N_strand) %>% c(., 40, 40) # This last value is not real!
)
x_lambda[,1] = scale(x_lambda[,1])

# Define harvest data
N_harvest = c(0,0)

# Input data -------------------------------------------------------------------
init_pcfg_data_3yr = list(
  n_dat_yrs = nrow(Ndata_input),  
  n_proj_yrs = 2,                      # number of years to project into the future
  n_betas = ncol(x_lambda),            # number of coefficients on lambda
  mu_logN_hat = Ndata_input$mean_log,  # estimated pop abundance, log space
  sigma_logN_hat = Ndata_input$sd_log,
  mu_logC_hat = Cdata_input %>% slice(1:nrow(Ndata_input)) %>% pull(mean_log),       # estimated ENP calf abundance, log space
  sigma_logC_hat = Cdata_input %>% slice(1:nrow(Ndata_input)) %>% pull(sd_log),
  mu_logC_proj = Cdata_input %>% slice(-c(1:nrow(Ndata_input))) %>% pull(mean_log),  # estimated contemporary ENP calf abundance, log space
  sigma_logC_proj = Cdata_input %>% slice(-c(1:nrow(Ndata_input))) %>% pull(sd_log),
  x_lambda_dat = as.matrix(x_lambda %>% slice(1:nrow(Ndata_input))),
  x_lambda_proj = as.matrix(x_lambda %>% slice(-c(1:nrow(Ndata_input)))),
  N_harvest = N_harvest
)

init_pcfg_data_2yr = list(
  n_dat_yrs = nrow(Ndata_input),  
  n_proj_yrs = 2,                      # number of years to project into the future
  n_betas = ncol(x_lambda),            # number of coefficients on lambda
  mu_logN_hat = Ndata_input$mean_log,  # estimated pop abundance, log space
  sigma_logN_hat = Ndata_input$sd_log,
  mu_logC_hat = Cdata_input %>% slice(1:nrow(Ndata_input)) %>% pull(mean_log),       # estimated ENP calf abundance, log space
  sigma_logC_hat = Cdata_input %>% slice(1:nrow(Ndata_input)) %>% pull(sd_log),
  mu_logC_proj = Cdata_input %>% slice(-c(1:nrow(Ndata_input))) %>% pull(mean_log),  # estimated contemporary ENP calf abundance, log space
  sigma_logC_proj = Cdata_input %>% slice(-c(1:nrow(Ndata_input))) %>% pull(sd_log),
  x_lambda_dat = as.matrix(x_lambda %>% slice(1:nrow(Ndata_input))),
  x_lambda_proj = as.matrix(x_lambda %>% slice(-c(1:nrow(Ndata_input)))),
  N_harvest = N_harvest[1:2]
)

init_pcfg_data_2yr_calves = list(
  n_dat_yrs = nrow(Ndata_input),  
  n_proj_yrs = 2,                      # number of years to project into the future
  n_betas = 1,            # number of coefficients on lambda
  mu_logN_hat = Ndata_input$mean_log,  # estimated pop abundance, log space
  sigma_logN_hat = Ndata_input$sd_log,
  mu_logC_hat = Cdata_input %>% slice(1:nrow(Ndata_input)) %>% pull(mean_log),       # estimated ENP calf abundance, log space
  sigma_logC_hat = Cdata_input %>% slice(1:nrow(Ndata_input)) %>% pull(sd_log),
  mu_logC_proj = Cdata_input %>% slice(-c(1:nrow(Ndata_input))) %>% pull(mean_log),  # estimated contemporary ENP calf abundance, log space
  sigma_logC_proj = Cdata_input %>% slice(-c(1:nrow(Ndata_input))) %>% pull(sd_log),
  x_lambda_dat = as.matrix(x_lambda %>% dplyr::select(N_pcfg_calves) %>% dplyr::slice(1:nrow(Ndata_input))),
  x_lambda_proj = as.matrix(x_lambda %>% dplyr::select(N_pcfg_calves) %>% slice(-c(1:nrow(Ndata_input)))),
  N_harvest = N_harvest[1:2]
)

init_pcfg_data_2yr_strands = list(
  n_dat_yrs = nrow(Ndata_input),  
  n_proj_yrs = 2,                      # number of years to project into the future
  n_betas = 1,            # number of coefficients on lambda
  mu_logN_hat = Ndata_input$mean_log,  # estimated pop abundance, log space
  sigma_logN_hat = Ndata_input$sd_log,
  mu_logC_hat = Cdata_input %>% slice(1:nrow(Ndata_input)) %>% pull(mean_log),       # estimated ENP calf abundance, log space
  sigma_logC_hat = Cdata_input %>% slice(1:nrow(Ndata_input)) %>% pull(sd_log),
  mu_logC_proj = Cdata_input %>% slice(-c(1:nrow(Ndata_input))) %>% pull(mean_log),  # estimated contemporary ENP calf abundance, log space
  sigma_logC_proj = Cdata_input %>% slice(-c(1:nrow(Ndata_input))) %>% pull(sd_log),
  x_lambda_dat = as.matrix(x_lambda %>% dplyr::select(N_strandings) %>% dplyr::slice(1:nrow(Ndata_input))),
  x_lambda_proj = as.matrix(x_lambda %>% dplyr::select(N_strandings) %>% slice(-c(1:nrow(Ndata_input)))),
  N_harvest = N_harvest[1:2]
)
```

```{r models, echo = FALSE, warning = FALSE, message = FALSE}

# STAN model definitions -------------------------------------------------------
# models <- list.files("./STAN", "*.stan$")
f_pcfg_base <- here::here('STAN', 'pcfg_lognorm_base.stan')
f_pcfg_ar1v1 <- here::here('STAN', 'pcfg_lognorm_ar1_v1.stan')
#f_pcfg_ar1v2 <- here::here('STAN', 'pcfg_lognorm_ar1_v2.stan')
f_pcfg_enp <- here::here('STAN', 'pcfg_lognorm_enp_calves.stan')
f_pcfg_covs <- here::here('STAN', 'pcfg_lognorm_covs.stan')
model_names <- factor(c("Base", "AR1v1", "ENP Calves", 
                        "Calves only", "Strandings only", "Calves/Strandings"), 
                        levels = c("Base", "AR1v1", "ENP Calves", 
                                   "Calves only", "Strandings only", "Calves/Strandings"),
                        labels = c("Base", "AR1", "ENP Calves","PCFG Calves only", "ENP Strandings only", "PCFG Calves + ENP Strandings"))
# model_names <- factor(c("Base", "AR1v1", "AR1v2", "ENP Calves", 
#                         "Calves only", "Strandings only", "Calves/Strandings"), 
#                         levels = c("Base", "AR1v1", "AR1v2", "ENP Calves", 
#                                    "Calves only", "Strandings only", "Calves/Strandings"),
#                         labels = c("Base", "AR1v1", "AR1v2", "ENP Calves","PCFG Calves only", "ENP Strandings only", "PCFG Calves + ENP Strandings"))

# Model file pointers
models <- list(f_pcfg_base, f_pcfg_ar1v1, f_pcfg_enp, 
               f_pcfg_covs, f_pcfg_covs, f_pcfg_covs)

# Specify input data
init_data <- list(#init_pcfg_data_3yr, init_pcfg_data_3yr, init_pcfg_data_3yr,
                  #init_pcfg_data_2yr,
                  init_pcfg_data_2yr, init_pcfg_data_2yr, init_pcfg_data_2yr, 
                  init_pcfg_data_2yr_calves, init_pcfg_data_2yr_strands,
                  init_pcfg_data_2yr)

# Compile models ---------------------------------------------------------------
cmodels <- purrr::map(models, cmdstanr::cmdstan_model, .progress = T)

# MCMC -------------------------------------------------------------------------
mfit <- purrr::map2(cmodels, init_data, \(x, i) x$sample(
  data = i,
  output_dir = here("out"),
  seed = 42,
  chains = 3,
  parallel_chains = 3,
  #iter_warmup = 6000, iter_sampling = 9000,
  adapt_delta = 0.99,
  show_messages = FALSE,
  show_exceptions = FALSE
))
save(mfit, model_names, file = here("out", "mfits.RData"))

# Prepping data for output -----------------------------------------------------
# Tidy draws
tfit = purrr::map(mfit, tidy_draws, .progress = T)
np <- purrr::map(mfit, nuts_params, .progress = T)

# Specify tresholds ------------------------------------------------------------
threshold_N = 192    # Threshold on abundance below which a hunt is closed
threshold_Nmin = 171 # Threshold on minimum abundance below which a hunt is closed

# Load truncated retrospective results
# See pcfg_lognorm_retro_analysis.R for details
load(here("out", "TruncatedRetroSummary_2025.dat"))

N_eval_retro_summ <- N_eval_retro_summ %>%
  filter(model != "AR1v2") %>%
  mutate(
    model = factor(model, 
                        levels = c("Base", "AR1v1", "ENP Calves", 
                                   "Calves only", "Strandings only", "Calves/Strandings"),
                        labels = c("Base", "AR1", "ENP Calves","PCFG Calves only", "ENP Strandings only", "PCFG Calves + ENP Strandings"))
    )
  # mutate(
  #   model = factor(model, 
  #                       levels = c("Base", "AR1v1", "AR1v2", "ENP Calves", 
  #                                  "PCFG Calves only", "ENP Strandings only", "PCFG Calves + ENP Strandings"),
  #                       labels = c("Base", "AR1v1", "AR1v2", "ENP Calves","PCFG Calves only", "ENP Strandings only", "PCFG Calves + ENP Strandings"))
  #   )
```

# *Model results*

## Coefficient estimates

@tbl-coefs provides $\beta$ coefficient estimates for models where coefficients for $\lambda$ were estimated. Lower CI and Upper CI correspond to the lower and upper 95% credible intervals. $Rhat$ values less than 1.01 indicate effective mixing within and across chains, producing reliable and consistent estimates for the parameters. $ESS$ is the effective sample size and is an indicator of chain sampling efficiency. Here, $ESS$ values greater than 300 indicate sufficient sampling has been achieved.

```{r, echo = FALSE, warning = FALSE, message = FALSE, results = "asis"}
#| label: tbl-coefs
#| tbl-cap: "Coefficient estimates for models with coefficients on log $\\lambda$."
#| html-table-processing: none

#coefs <- tidy_coefs(mfit, model_names)

coefs <- purrr::imap(mfit, ~ .x$summary() %>%
                     mutate(model = model_names[.y]) %>%
                     filter(grepl("beta", variable)))

coefs_tab <- do.call('rbind', coefs) %>%
    dplyr::select(model, variable, mean, median, sd, lo_ci = q5, hi_ci = q95, rhat, ess_bulk) %>%
    mutate(
      variable = c('$\\beta_{Calves}$', '$\\beta_{Calves}$', '$\\beta_{Strandings}$', '$\\beta_{Calves}$', '$\\beta_{Strandings}$')
    )
    # mutate(
    #   variable = c('$\\beta_{Calves}$', '$\\beta_{Calves}$', '$\\beta_{Strandings}$', '$\\beta_{Calves}$', '$\\beta_{Strandings}$')
    # )

kable(coefs_tab,
  digits = c(rep(0, 2), rep(3, 6), 1),
  row.names = F,
  col.names = c("Model", "Variable", "Mean", "Median", "SD", "Lower CI", "Upper CI", "Rhat", "ESS_bulk"),
  align = c("l", rep("c", 8)),
  format = "simple",
  booktabs = T,
  escape = F) %>%
kable_classic(full_width = T, html_font = "Cambria")
```

## Leave-one-out Cross Validation (LOO) {#leave-one-out}

@tbl-loo provides estimates of model fit using an information criterion (leave-one-out information criterion; *looic*) based on leave-one-out cross validation [@vehtari2017practical]. Models with the lowest $looic$ value are considered the best fitting model given the time series of abundance data used to fit the model. $\Delta looic$ represents the difference in $looic$ relative to the model with the lowest $looic$.

```{r loo, echo = FALSE, warning = FALSE, message = FALSE}
#| label: tbl-loo
#| tbl-cap: "Derived estimates of model fit using an information criterion based on leave-one-out cross validation (looic)."
#| html-table-processing: none
loo_pcfg <- purrr::map(mfit, \(x) x$loo(cores = 4, k_threshold = 0.7))
#purrr::map(loo_pcfg, plot)

tab_loo <- purrr::map_dfr(loo_pcfg, \(x) 
                          data.frame(
                            elpd_loo = x$elpd_loo, elpd_loo_se = x$se_elpd_loo,
                            p_loo = x$p_loo, p_loo_se = x$se_p_loo,
                            looic = x$looic, looic_se = x$se_looic
                          )) %>%
  add_column(
    Model = model_names,
    .before = 1
  ) %>% 
  arrange(looic) %>%
  mutate(
    deltaLooic = looic - min(looic)
  )

# HTML table output
# DT::datatable(tab_loo, 
#               rownames = F,
#           options = list(
#             dom = 't',
#             columnDefs = list(list(className = 'dt-center', targets = 1:4))
#             )) %>%
#   DT::formatRound(2:5, 2)

# For GFM-based readme
knitr::kable(
  tab_loo,
  digits = 2,
  align = c("l", rep("c", 7)),
  format = "html",
  booktabs = T
) %>%
kable_classic(full_width = T, html_font = "Cambria")
```

## Predictive accuracy with retrospection {#retrospective}

Given that prediction was the primary objective of this exercise, we evaluated the ability of each model to retrospectively predict a "future", known population abundance using the PCFG abundance time series from [@harrisPCFG2025]. Predicting future states, or "forecasting", is notoriously challenging particularly as we project further into the future. However, within this system, data gaps of one or two years represent the most plausible scenarios managers are likely to encounter, providing the basis for our evaluation. In addition, we anticipated relative performance within model sets was likely to vary as we projected further into the future. Thus, in order to document a potential shift in model support in relation to projection length, we evaluated predictive performance when projecting one and two years separately. Finally, we evaluated predictive performance using models fitted to both truncated and complete abundance time series. The latter provides the best available knowledge of the system for model fitting, but might bias retrospective evaluations of predictive performance due to information "spillover" from future observed population states. The former can become data limited and select for overly simplistic models as time series shorten.

All time series used in model fitting started with estimates from `r minYr`, but varied in their end point. In the case of truncated times series, we fit each of the six specified models to multiple time series with varying end points from 2013 through `r maxYr - 2`, providing projected abundance estimates for years 2014 through `r maxYr`. Notably, we evaluated endpoints between 2006 and 2012, but these shorter time series were inadequate for model convergence. In the case of the complete time series, we fit all six models to a single time series representing abundance data from 2002 through `r maxYr`. Model parameters were then used to retrospectively project abundance forward one or two years from 2002 through `r maxYr - 2`, providing projected abundance estimates for years 2003 through `r maxYr`.

In all cases, projected estimates were then compared to "observed" abundance in the same year using residual sum of squares (RSS), the quantile for observed abundance, 60% and 95% credible intervals, and whether an estimate dropped below threshold resulting in a presumed hunt closure. Predictive fits were summarized by one or two year projection lengths.

### *Model fits derived from truncated time series* {#model-fits-trunc}

The following tables show predictive performance statistics by model specification when predicting one (@tbl-tRetro1summ) or two years forward (@tbl-tRetro2summ) from all data years between 2013 and `r maxYr - 2` using the truncated time series described above. Makah hunt closures will be imposed when N falls below `r threshold_N` or N~min~ falls below `r threshold_Nmin`.

::: panel-tabset
### Projected year 1 (Table 3)

```{r tbl-tRetro1summ, echo = F, warning = F, message = F}
#| label: tbl-tRetro1summ
#| tbl-cap: "Model prediction statistics for one year projections using data years 2013 through 2022 as starting points. Models were fitted using truncated time series, including data up to projected year - 1. mnRSS is the mean residual sum of squares."
#| html-table-processing: none
N_eval_summary_proj1yr <- N_eval_retro_summ %>%
  filter(proj_set == "1 yr") %>%
  filter(year > 2013) %>%
  group_by(model) %>%
  summarize(
    mnRSS = mean(rss),
    #mdRSS = median(rss),
    mnPercentile_abundEstN = mean(percentile_abundEstN),
    mdPercentile_abundEstN = median(percentile_abundEstN),
    mnProp_below_threshold = mean(prop_below_threshold),
    mdProp_below_threshold = median(prop_below_threshold),
    closures_Nmin = sum(closure_Nmin),
    closures_N = sum(closure_N),
    closures = sum(closure),
    closure_years = paste(cur_data()$year[closure == T], collapse = ",")
  ) %>%
  arrange(mnRSS)

# For GFM-based readme
knitr::kable(
  N_eval_summary_proj1yr,
  row.names = F,
  col.names = c("Model", "Mean RSS", #"Median RSS", 
                "Mean Percentile (N)",
                "Median Percentile (N)",
                "Mean Prop Below Threshold (N)",
                "Median Prop Below Threshold (N)",
                "Number of Closures (N<sub>min</sub>)", "Number of Closures (N)",
                "Number of Closures", "Closure Years"),
  digits = c(rep(1, 2), rep(3, 4), rep(0, 4)),
  align = c("l", rep("c", 8)),
  format = "html",
  booktabs = T, escape = F
) %>%
kable_classic(full_width = T, html_font = "Cambria")
```

### Projected year 2 (Table 4)

```{r tbl-tRetro2summ, echo = F, warning = F, message = F}
#| label: tbl-tRetro2summ
#| tbl-cap: "Model prediction statistics for two year projections using data years 2013 through 2021 as starting points. Models were fitted using truncated time series, including data up to projected year - 1. mnRSS is the mean residual sum of squares."
#| html-table-processing: none
N_eval_summary_proj2yr <- N_eval_retro_summ %>%
  filter(proj_set == "2 yr" & year != 2024) %>%
  filter(year > 2013) %>%
  group_by(model) %>%
  summarize(
    mnRSS = mean(rss),
    #mdRSS = median(rss),
    mnPercentile_abundEstN = mean(percentile_abundEstN),
    mdPercentile_abundEstN = median(percentile_abundEstN),
    mnProp_below_threshold = mean(prop_below_threshold),
    mdProp_below_threshold = median(prop_below_threshold),
    closures_Nmin = sum(closure_Nmin),
    closures_N = sum(closure_N),
    closures = sum(closure),
    closure_years = paste(cur_data()$year[closure == T], collapse = ",")
  ) %>%
  arrange(mnRSS)

# For GFM-based readme
knitr::kable(
  N_eval_summary_proj2yr,
  row.names = F,
  col.names = c("Model", "Mean RSS", #"Median RSS", 
                "Mean Percentile (N)",
                "Median Percentile (N)",
                "Mean Prop Below Threshold (N)",
                "Median Prop Below Threshold (N)",
                "Number of Closures (N<sub>min</sub>)", "Number of Closures (N)",
                "Number of Closures", "Closure Years"),
  digits = c(rep(1, 2), rep(3, 4), rep(0, 4)),
  align = c("l", rep("c", 8)),
  format = "html",
  booktabs = T, escape = F
) %>%
kable_classic(full_width = T, html_font = "Cambria")
```
:::

@fig-truncRetroFig1 depicts the predictive fits when abundance was projected forward one (top panel) or two years (bottom panel) for all model specifications in a truncated time series context. Observed abundance estimates for years 2014 through `r maxYr` are represented as back diamonds, median model predictions are represented by points, 60% credible intervals are depicted as solid error bars, and the 95% credible intervals are depicted as dashed error bars.

```{r truncRetroFig1, echo = F, warning = F, message = F, fig.height = 8, fig.width = 10, dpi = 300}
#| label: fig-truncRetroFig1
#| fig-cap: "The predictive fits when abundance was projected forward one (top panel) or two years (bottom panel) for all model specifications in a truncated time series context. Observed abundance estimates for years 2014 through 2023 are represented as back diamonds, median model predictions are represented by points, 60% credible intervals are depicted as solid error bars, and the 95% credible intervals are depicted as dashed error bars."
#| 
N_eval_table_trunc <- N_eval_retro_summ %>%
  filter(year > 2013& year != 2024) #%>%  
  # mutate(model = factor(model, 
  #                       levels = c("Base", "AR1v1", "AR1v2", "Calves/Strandings", 
  #                                  "Calves only", "Strandings only", "ENP Calves")))

tidy_plot_retroPred(N_eval_table_trunc, ylims = c(0, 500), truncated_retro = T)

# N_eval_table <- N_eval_table_trunc %>%
#   mutate(
#     proj_set = factor(proj_set, levels = c("1 yr", "2 yr"), 
#                       labels = rep(paste("Projected year", 1:2)))
#   )
# 
# width <- 0.5
# 
# N_eval_table %>% 
#   filter(proj_set == "Projected year 1") %>%
#   ggplot(aes(x = year, y = abundEst, group = model, color = model)) +
#   #facet_wrap(~ proj_set, ncol = 1) + 
#   geom_errorbar(aes(ymin = loN_ci, ymax = hiN_ci), linetype = 2, width = width, 
#                 position = position_dodge(width = width)) + 
#   geom_errorbar(aes(ymin = percentile_20, ymax = percentile_80), width = width, 
#                 position = position_dodge(width = width)) +
#   #geom_point(aes(x = year, y = meanN), position = position_dodge(width = width)) +
#   geom_point(aes(x = year, y = medianN), position = position_dodge(width = width)) +
#   geom_point(size = 2, color = "black", fill = "black", shape = 23) +
#   scale_color_paletteer_d("Manu::Kotare") +
#   coord_cartesian(ylim = c(0, 350)) +
#   #scale_y_continuous(limits = ylims, oob = scales::squish) +
#   labs(x = "Year", y = "PCFG Abundance") +
#   scale_x_continuous(limits = c(min(N_eval_table$year) - 1.5, max(N_eval_table$year)) + 1, 
#                      breaks = seq(min(N_eval_table$year), max(N_eval_table$year), 1),
#                      expand = c(0,0)) +
#   guides(color = guide_legend(title = NULL, position = "top", direction = "horizontal", nrow = 1)) +
#   theme_bw()
```

### *Model fits derived from full time series* {#model-fits-full}

The following tables show predictive performance statistics by model specification when predicting one (@tbl-retro1summ) or two years forward (@tbl-retro2summ) for all data years from 2002 through `r maxYr - 2` using the full time series. As stated above, Makah hunt closures will be imposed when N falls below `r threshold_N` or N~min~ falls below `r threshold_Nmin`.

::: panel-tabset
### Projected year 1 (Table 5)

```{r retro1summ, echo = F, warning = F, message = F}
#| label: tbl-retro1summ
#| tbl-cap: "Model prediction statistics for one year projections using data years 2002 through 2022 as starting points. Models were fit using the full time series. RSS is the residual sum of squares."
#| html-table-processing: none
# Retrospective prediction -----------------------------------------------------
N_eval_table <- pred_summary_tbl_multimodel(Ndata_input, tfit, model_names, threshold_N, threshold_Nmin)
save(N_eval_table, file = here("out", "RetroSummary.dat"))

N_eval_summary_proj1yr <- N_eval_table %>%
  filter(proj_set == "pyear1") %>%
  group_by(model) %>%
  summarize(
    mnRSS = mean(rss), 
    mnPercentile_abundEstN = mean(percentile_abundEstN),
    mdPercentile_abundEstN = median(percentile_abundEstN),
    mnProp_below_threshold = mean(prop_below_threshold),
    mdProp_below_threshold = median(prop_below_threshold),
    closures_Nmin = sum(closure_Nmin),
    closures_N = sum(closure_N),
    Nclosures = sum(closure),
    closure_years = paste(cur_data()$year[closure == T], collapse = ",")
  ) %>%
  arrange(mnRSS)

# For GFM-based readme
knitr::kable(
  N_eval_summary_proj1yr,
  row.names = F,
  col.names = c("Model", "Mean RSS", #"Median RSS", 
                "Mean Percentile (N)",
                "Median Percentile (N)",
                "Mean Prop Below Threshold (N)",
                "Median Prop Below Threshold (N)",
                "Number of Closures (N<sub>min</sub>)", "Number of Closures (N)",
                "Number of Closures", "Closure Years"),
  digits = c(rep(1, 2), rep(3, 4), rep(0, 4)),
  align = c("l", rep("c", 8)),
  format = "html",
  booktabs = T, escape = F
) %>%
kable_classic(full_width = T, html_font = "Cambria")
```

### Projected year 2 (Table 6)

```{r retro2summ, echo = F, warning = F, message = F}
#| label: tbl-retro2summ
#| tbl-cap: "Model prediction statistics for two year projections using data years 2002 through 2021 as starting points. Models were fit using the full time series. RSS is the residual sum of squares."
#| html-table-processing: none
N_eval_summary_proj2yr <- N_eval_table %>%
  filter(proj_set == "pyear2") %>%
  group_by(model) %>%
  summarize(
    mnRSS = mean(rss), 
    mnPercentile_abundEstN = mean(percentile_abundEstN),
    mdPercentile_abundEstN = median(percentile_abundEstN),
    mnProp_below_threshold = mean(prop_below_threshold),
    mdProp_below_threshold = median(prop_below_threshold),
    closures_Nmin = sum(closure_Nmin),
    closures_N = sum(closure_N),
    Nclosures = sum(closure),
    closure_years = paste(cur_data()$year[closure == T], collapse = ",")
  ) %>%
  arrange(mnRSS)

# For GFM-based readme
knitr::kable(
  N_eval_summary_proj2yr,
  row.names = F,
  col.names = c("Model", "Mean RSS", #"Median RSS", 
                "Mean Percentile (N)",
                "Median Percentile (N)",
                "Mean Prop Below Threshold (N)",
                "Median Prop Below Threshold (N)",
                "Number of Closures (N<sub>min</sub>)", "Number of Closures (N)",
                "Number of Closures", "Closure Years"),
  digits = c(rep(1, 2), rep(3, 4), rep(0, 4)),
  align = c("l", rep("c", 8)),
  format = "html",
  booktabs = T, escape = F
) %>%
kable_classic(full_width = T, html_font = "Cambria")
```
:::

@fig-retroFig depicts the predictive fits when abundance was projected forward one (top panel) or two years (bottom panel) for all model specifications. Observed abundance estimates for years 2003 through `r maxYr` are represented as back diamonds, median model predictions are represented by points, 60% credible intervals are depicted as solid error bars, and the 95% credible intervals are depicted as dashed error bars .

```{r fig-retroFig, echo = F, warning = F, message = F, fig.height = 8, fig.width = 10, dpi = 300}
#| label: fig-retroFig
#| fig-cap: "The predictive fits when abundance was projected forward one (top panel) or two years (bottom panel) for all model specifications using the full time series. Observed abundance estimates for years 2003 through 2023 are represented as back diamonds, median model predictions are represented by points, 60% credible intervals are depicted as solid error bars, and the 95% credible intervals are depicted as dashed error bars."

tidy_plot_retroPred(N_eval_table)
```

# *Model-predicted population trends*

@fig-trendFig depicts the predicted trends in PCFG gray whale abundance by state-space model specification during data years (`r min(Ndata_input$year)` - `r max(Ndata_input$year)`), as well as abundance projections for two years beyond (through `r max(Ndata_input$year) + 2`). The black points and red diamonds correspond to the mean PCFG abundance and N~min~, respectively, and were derived from a mark-resight population model published in [@harrisPCFG2022]. The solid error bars represent the 95% confidence intervals on mean estimates form the mark-resight model. The solid black trend line represents the state-space model predicted mean abundance. The lighter gray ribbon represents the 95% credible interval with the darker ribbon reflecting the 60% credible interval, with the lower bounds capturing estimated N~min~. The solid and dashed horizontal gray lines correspond to the management closure thresholds for N and N~min~, respectively.

```{r fig-trendFig, echo = F, warning = F, message = F, fig.height = 18, fig.width = 8, dpi = 600}
#| label: fig-trendFig
#| fig-cap: "Predicted trends in PCFG gray whale abundance by state-space model specification during data years (2002 - 2023), as well as abundance projections for two years beyond (through 2025). The black points and red diamonds correspond to the mean PCFG abundance and Nmin, respectively, and were derived from a mark-resight population model. The solid error bars represent the 95% confidence intervals on mean estimates form the mark-resight model. The solid black trend line represents the state-space model predicted mean abundance. The lighter gray ribbon represents the 95% credible interval with the darker ribbon reflecting the 60% credible interval, with the lower bounds capturing estimated N~min~. The solid and dashed horizontal gray lines correspond to the management closure thresholds for N (N < 192) and N~min~ (N~min~ < 171), respectively."

# Population trajectories 
tidy_plot_traj_multimodel(Ndata_input, tfit, model_names, threshold_N, threshold_Nmin, ncols = 1)
```

## Model-averaged population trend and predictions for `r maxYr + 2`

```{r fig-stackedTrendFig, echo = F, warning = F, message = F, eval = F, fig.height = 4, fig.width = 8, dpi = 300}
#| label: fig-stackedTrendFig
#| fig-cap: "Estimated trend in PCFG gray whale abundance derived from model-averaged estimates using weights based on pseudo-BMA weights with bootstrapping. Abundance trends capture data years (2002 - 2023) and a two-year projection through 2025. The black points and red diamonds correspond to the mean PCFG abundance and N~min~, respectively, and were derived from a mark-resight population model. The solid error bars represent the 95% confidence intervals on mean estimates form the mark-resight model. The solid black trend line represents the state-space model predicted mean abundance. The lighter gray ribbon represents the 95% credible interval with the darker ribbon reflecting the 60% credible interval, with the lower bounds capturing estimated N~min~."

# Model averaged abundance
ma_abund <- tidy_model_avg(tfit, wgts, iters = 1000, Ndata_input, 101)

# Figure
Ndata_input %>% 
  ggplot(aes(x = year, y = N)) +  
  geom_ribbon(data = ma_abund, aes(y = mean, ymin = percentile_20, ymax = percentile_80), alpha = 0.2) +
  geom_ribbon(data = ma_abund, aes(y = mean, ymin = lo_ci, ymax = hi_ci), alpha = 0.2) +
  geom_line(data = ma_abund, aes(y = mean)) +
  geom_point(size = 3, color = "white", fill = "black", shape = 21) +
  scale_x_continuous(limits = c(min(ma_abund$year), max(ma_abund$year)), 
                       breaks = seq(min(ma_abund$year), max(ma_abund$year), by = 1), minor_breaks = NULL) +
  scale_y_continuous(limits = c(0, 350), breaks = seq(0, 350, by = 100)) +
  geom_hline(yintercept = threshold_N) + 
  geom_hline(yintercept = threshold_Nmin, linetype = 2, color = "red") +
  geom_errorbar(aes(ymin = low_95CI, ymax = high_95CI)) +  
  geom_errorbar(aes(ymin = low_60CI, ymax = N), linewidth = 0) +
  geom_point(aes(y = low_60CI), shape = 23, fill = "red", size = 2) +
  theme_bw(base_size = 16) +
  labs(x = "Year", y = "PCFG Abundance") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  NULL
```

```{r tbl-modelPrediction2yr, echo = F, warning = F, message = F}
#| label: tbl-modelPrediction2yr
#| tbl-cap: "Model weights derived using pseudo-Bayesian model averaging with bootstrapping (pseudoBMA+) for all models without ENP strandings. Model predicted abundance (N) and minimum abundance (N~min~) for PCFG gray whales in 2025."
#| html-table-processing: none

# Model weights
wgts_stacked <- loo_model_weights(loo_pcfg[1:4])
wgts <- loo_model_weights(loo_pcfg[1:4], method = "pseudobma", BB = TRUE)

wgts_tab <- data.frame(Model = model_names[1:4], Stacking = as.numeric(wgts_stacked), PseudoBMA = as.numeric(wgts))

sub_wgts <- wgts_tab %>%
  filter(Model != "AR1") %>% 
  pull(PseudoBMA) %>% sum()

# Model averaged abundance
ma_abund <- tidy_model_avg(tfit[1:4], wgts[1:4], iters = 1000, Ndata_input, 101)

# Projected estimated final abundance + 2 years (posterior draws) -----------------
lastYr <- "logN_proj[2]"
postLastYr <- purrr::imap(tfit, ~.x[lastYr] %>% add_column(Model = model_names[.y]))
postLastYr <- do.call(rbind, postLastYr)

maDraws <- ma_abund$draws %>%
  filter(year == maxYr + 2) %>%
  mutate(Model = "Model-averaged estimate") %>%
  dplyr::select(
    `logN_proj[2]` = logN, Model
  )

postLastYr <- rbind(postLastYr, maDraws) %>%
  filter(!grepl("Strandings", Model))

# Summarizing last projected year and appending model-averaged estimate           
postLastYr_mns <- postLastYr %>%
  group_by(Model) %>%
  summarize(
    Nmean = exp(mean(`logN_proj[2]`)),
    Nmin = quantile(exp(`logN_proj[2]`), 0.2)
  )

summTab <- wgts_tab %>% full_join(postLastYr_mns, by = "Model")

options(knitr.kable.NA = '')
kable(summTab %>% dplyr::select(-Stacking),
  row.names = F,
  col.names = c("Model", "PseudoBMA+", "N", "N<sub>min</sub>"),
  digits = c(0, 3, 1, 1),
  align = c("l", rep("c", 3)),
  format = "html",
  booktabs = T,
  escape = F) %>%
kable_classic(full_width = F, html_font = "Cambria")
```

@tbl-modelPrediction2yr captures the estimated model weights, and therefore relative support for each, when averaging estimates into a single, unified prediction using pseudo-Bayesian model averaging with bootstrapping [@yaoStacking2018]. Model weights favored the AR1 model, with the remaining `r sprintf("%.1f", sub_wgts * 100)`% of the model weight divided among base, ENP calves, and PCFG calves models. After accounting for estimated model weights, model-average prediction for the trend in PCFG abundance is depicted in @fig-stackedTrendFig_subset.

```{r fig-stackedTrendFig_subset, echo = F, warning = F, message = F, fig.height = 4, fig.width = 8, dpi = 300}
#| label: fig-stackedTrendFig_subset
#| fig-cap: "Estimated trend in PCFG gray whale abundance derived from model-averaged estimates (without ENP strandings) using weights based on pseudo-BMA weights with bootstrapping. Abundance trends capture data years (2002 - 2023) and a two-year projection through 2025. The black points and red diamonds correspond to the mean PCFG abundance and N~min~, respectively, and were derived from a mark-resight population model. The solid error bars represent the 95% confidence intervals on mean estimates form the mark-resight model. The solid black trend line represents the state-space model predicted mean abundance. The lighter gray ribbon represents the 95% credible interval with the darker ribbon reflecting the 60% credible interval, with the lower bounds capturing estimated N~min~. The solid and dashed horizontal gray lines correspond to the management closure thresholds for N (N < 192) and N~min~ (N~min~ < 171), respectively."

# Figure
Ndata_input %>% 
  ggplot(aes(x = year, y = N)) +  
  geom_ribbon(data = ma_abund$summary, aes(y = mean, ymin = percentile_20, ymax = percentile_80), alpha = 0.2) +
  geom_ribbon(data = ma_abund$summary, aes(y = mean, ymin = lo_ci, ymax = hi_ci), alpha = 0.2) +
  geom_line(data = ma_abund$summary, aes(y = mean)) +
  geom_point(size = 3, color = "white", fill = "black", shape = 21) +
  scale_x_continuous(limits = c(min(ma_abund$summary$year), max(ma_abund$summary$year)), 
                       breaks = seq(min(ma_abund$summary$year), max(ma_abund$summary$year), by = 1), minor_breaks = NULL) +
  scale_y_continuous(limits = c(0, 350), breaks = seq(0, 350, by = 100)) +
  geom_hline(yintercept = threshold_N, color = "#4d4d4d") + 
  geom_hline(yintercept = threshold_Nmin, linetype = 2, color = "#4d4d4d") +
  geom_errorbar(aes(ymin = low_95CI, ymax = high_95CI)) +  
  geom_errorbar(aes(ymin = low_60CI, ymax = N), linewidth = 0) +
  geom_point(aes(y = low_60CI), shape = 23, fill = "red", size = 2) +
  theme_bw(base_size = 16) +
  labs(x = "Year", y = "PCFG Abundance") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank()
  ) +
  NULL
```

@tbl-modelPrediction2yr and @fig-final-proj provide predictions for the near-future state of the PCFG gray whale population. All estimates, including those from individual models, predict the PCFG population is above the management thresholds for both N and N~min~ in `r maxYr + 2`. @tbl-modelPrediction2yr provides the point estimates for N and N~min~, and @fig-final-proj depicts the posterior predictions by model. For the figure, the portion of the posterior distributions filled in light gray capture the lower 20% credible interval, the upper threshold of which represents the estimated N~min~. If this threshold drops below the dashed line, it would trigger a management closure.

```{r tbl-modelPrediction2yr_v0, echo = F, warning = F, eval = F, message = F}
#| label: tbl-modelPrediction2yr_v0
#| tbl-cap: "Predicted N and N~min~ for PCFG gray whales in 2025 based on a two year projection from the last documented abundance estimate (2023)."
#| html-table-processing: none

# Projected estimated final abundance + 2 years (posterior draws) -----------------
lastYr <- "logN_proj[2]"
postLastYr <- purrr::imap(tfit, ~.x[lastYr] %>% add_column(Model = model_names[.y]))
postLastYr <- do.call(rbind, postLastYr)

maDraws <- ma_abund$draws %>%
  filter(year == maxYr + 2) %>%
  mutate(Model = "Model-averaged estimate") %>%
  dplyr::select(
    `logN_proj[2]` = logN, Model
  )

postLastYr <- rbind(postLastYr, maDraws)  %>%
  filter(!grepl("Strandings", Model))

# Summarizing last projected year and appending model-averaged estimate           
postLastYr_mns <- postLastYr %>%
  group_by(Model) %>%
  summarize(
    Nmean = exp(mean(`logN_proj[2]`)),
    Nmin = quantile(exp(`logN_proj[2]`), 0.2)
  )

kable(postLastYr_mns,
  row.names = F,
  col.names = c("Model", "N", "N<sub>min</sub>"),
  digits = 1,
  align = c("l", rep("c", 2)),
  format = "html",
  booktabs = T,
  escape = F) %>%
kable_classic(full_width = F, html_font = "Cambria")
```

```{r finalEstimates, echo = F, warning = F, message = F, fig.height = 4, fig.width = 8, dpi = 300}
#| label: fig-final-proj
#| fig-cap: "Model-specific estimated abundance in the second year of projections (2025). Median estimates are represented by vertical boundaries between dark gray and white. N~min~ estimates (lower 20% CIs) are represented by the boundaries between light gray and dark gray. The solid and dashed black, vertical lines correspond to the management closure thresholds for N and N~min~, respectively."

# ggplot(postLastYr, aes(group = Model, fill = Model, color = Model)) +
#   geom_density_ridges(aes(x = exp(`logN_proj[2]`), y = Model), 
#                       quantile_lines = T, quantiles = c(0.2, 0.5), 
#                       alpha = 0.7, color = "white",
#                       scale = 2.5, rel_min_height = .01) +
#   geom_vline(aes(xintercept = threshold_N), color = "black") +
#   geom_vline(aes(xintercept = threshold_Nmin), linetype = 2, color = "black") +
#   viridis::scale_fill_viridis(discrete = T, option = "D") +
#   scale_x_continuous(limits = c(0, 400)) +
#   labs(x = "Projected N (Year 2025)", y = NULL) +
#   guides(fill = "none") +
#   theme_minimal() +
#   #theme_ridges(grid = FALSE) #+
#   theme(
#     panel.grid.major.x = element_blank(),
#     panel.grid.minor.x = element_blank()
#   )

ggplot(postLastYr, aes(x = exp(`logN_proj[2]`), y = Model, fill = factor(stat(quantile)))) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE,
    quantiles = c(0.2, 0.5),
    color = "#A0A0A0A0"
  ) +
  scale_fill_manual(
    name = "Probability", values = c("#999999A0", "#444444A0", "#FFFFFF"),
    labels = c("(0, 0.2]", "(0.2, 0.5]", "(0.5, 1]")
  ) +
  geom_vline(aes(xintercept = threshold_N), color = "black") +
  geom_vline(aes(xintercept = threshold_Nmin), linetype = 2, color = "black") +
  scale_x_continuous(limits = c(0, 400)) +
    scale_y_discrete(limits=rev) +
  labs(x = "Projected N (Year 2025)", y = NULL) +
  guides(fill = "none") +
  theme_minimal() +
  #theme_ridges(grid = FALSE) #+
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  )

# ggplot(postLastYr, aes(group = Model, fill = Model, color = Model)) +
#   geom_density(aes(x = exp(`logN_proj[2]`)), alpha = 0.4) +
#   geom_rug(aes(x = threshold_N), color = "black", linewidth = 1.5) +
#   geom_rug(aes(x = threshold_Nmin), color = "red", linewidth = 1.5) +
#   # vline_at(threshold_N, linetype = 2) +
#   # vline_at(threshold_Nmin, color = "red", linetype = 2) +
#   geom_vline(data = postLastYr_mns %>% filter(Model != "Model-averaged estimate"), aes(xintercept = Nmean, group = Model, color = Model),
#              alpha = 1, linewidth = 0.8, linetype = 3) +
#   viridis::scale_fill_viridis(discrete = T, option = "B") +
#   viridis::scale_color_viridis(discrete = T, option = "B") +
#   scale_x_continuous(limits = c(0, 350)) +
#   guides(
#     color = guide_legend(title = NULL, position = "top", direction = "horizontal", nrow = 1),
#     fill = guide_legend(title = NULL, position = "top", direction = "horizontal", nrow = 1)) +
#   labs(x = "Projected N (Year 2025)", y = "Density") +
#   theme_bw()
```

```{r, echo = F, warning = F, message = F}
# For front page matter
mainPred <- ma_abund$summary %>%
  slice((n()-1):n()) %>%
  dplyr::select(year, N = mean, Nmin = percentile_20)

save(mainPred, Ndata_input, summTab, ma_abund, file = here("out", "front_page_matter.Rdata"))
```
